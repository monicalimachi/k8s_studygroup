# k8s_studygroup
***
## Some Commands
```
k get deployments name_deploy -o yaml > the_name.yaml
k get pods name_pod -o yaml > the_new.yaml
```
***
## SERVICE ACCOUNTS
### User account
2 types of accounts in K8s. A user account and a serviceaccount. 
- user account is used by humans. 
- service accounts are used by machines. 
### Tasks
- A user account could be for an administrator accessing the cluster to perform administrative tasks, a developer accessing the cluster to deploy applications etc. 
- A service account, could be an account used by an application to interact with the kubernetes cluster. 
```
For example a monitoring application like Prometheus uses a service account to poll the kubernetes API for performance metrics. 
An automated build tool like Jenkins uses service accounts to deploy applications on the kubernetes cluster.
```
### Service account
It first creates the service account object
Creates the secret object, linked to service account
```
kubectl describe serviceaccount name_service_account
kubectl describe secret token_from_service_account
kubectl get serviceaccount
kubectl get sa --all-namespaces | grep default
```
- Create a service account and us
- Assign the role permissions
- Export your service account tokens
Example of service account: kubectl apply -f newservice-account.yaml
```
apiVersion: v1
kind: Secret
metadata:
  name: build-robot-secret
  annotations:
    kubernetes.io/service-account.name: build-robot
type: kubernetes.io/service-account-token
```
Now we can use it for secrets

```kubectl describe secrets/build-robot-secret
```
***

## RESOURCE LIMITS
```
free
docker
kubectl

```
### Default memory

```
apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
spec:
  limits:
  - default:
      memory: 512Mi
    defaultRequest:
      memory: 256Mi
    type: Container
  ```
  https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/ 

### Default CPU

```
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-limit-range
spec:
  limits:
  - default:
      cpu: 1
    defaultRequest:
      cpu: 0.5
    type: Container
```    
https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/

### References
https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource

## TAINTS & TOLERATIONS
   * Restrict nodes from accepting certain pods 

1. Nodes = Taints 
2. Pods = Tolerations
3. Master = Do not deploy app
```
kubectl taint nodes node-name key=value:taint-effect
kubectl describe node kubemaster | grep Taint
```
###NoSchedule | PreferNoSchedule|NoExecute
What happens to PODs thar DO NOT TLERATE this taint?
- NoSchedule: Pods no will be schedule in node
- PreferNoSchedule: System will try to avoid placing the pod on the node, no guarenteed
- No execute: New pods will not be schedule on the node and existing pods on the node if any will be evicted if they do not tolerate the taint. 
  This pods may have been scheduled on the node before the taint was applied to the node
Example
```
kubectl taint nodes node1 app=blue:NoSchedule
```

## NODE SELECTORS
- Label a node
```
kubectl label nodes <nde_name> <label-key>=<label-value>
kubectl label nodes node-1 size=Large
```
En el yaml file
```
nodeSelector: 
  size: Large
```

## NODE AFFINITY
Ensure that pods are hosted on particular nodes
Large pods inside large nodes
```
affinity:
 nodeAffinity:
   requiredDuringSchedulingIgnoreDuringExecution:
     nodeSelectorTerms:
     - nodeSelectorTerms:
       - matchExpressions:
         - key: size
           operator: Exists / * NotIn
           * values:
           * - Small
```
Types: Available
- requiredDuringSchedulingIgnoreDuringExecution
- preferedDuringSchedulingIgnoreDuringExecution
Types: 
- requiredDuringSchedulingRequiredDuringExecution

