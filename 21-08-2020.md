# k8s_studygroup
***
## Some Commands
```
k get deployments name_deploy -o yaml > the_name.yaml
k get pods name_pod -o yaml > the_new.yaml
```
***
## SERVICE ACCOUNTS
### User account
Two types of accounts in K8s. 

- A user account:Humans. An administrator accessing the cluster to perform administrative tasks, a developer accessing the cluster to deploy applications etc. 
- A service account: Used by machines. An account used by an application to interact with the kubernetes cluster. 
```
For example
Monitoring application like Prometheus uses a service account to poll the kubernetes API for performance metrics. 
An automated build tool like Jenkins uses service accounts to deploy applications on the kubernetes cluster.
```
### Details
- First Create a service account object and use it
- Creates the secret object, linked to service account
- Assign the role permissions
- Export your service account tokens
  >Example of service account: kubectl apply -f newservice-account.yaml

### ImagePull Secrets to a service account
```
kubectl create secret docker-registry myregistrykey --docker-server=DUMMY_SERVER \
        --docker-username=DUMMY_USERNAME --docker-password=DUMMY_DOCKER_PASSWORD \
        --docker-email=DUMMY_DOCKER_EMAIL
```
### Add the registry to a serviceaccount
```
kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "myregistrykey"}]}'
``` 
### Commands
```
kubectl get serviceaccount
kubectl get sa --all-namespaces | grep default
kubectl create serviceaccount dashboard-sa
kubectl describe serviceaccount name_service_account
kubectl describe secret token_from_service_account
```

> Read more: https://kubernetes.io/docs/reference/access-authn-authz/authentication/

***
## RESOURCE LIMITS
```

- docker: Consume as much resources as it requires: 

- kubectl: Pending - Insufficient memory - terminate

```
- The minimum CPU: 0.5
- The minimum Memory: 256 Mi

### CPU: 0.1 = 100m and  lower 1m (m=mili)
  - 1 CPU = 1AWS vCPU = 1GCP Core= 1 Azure Core = 1 Hyperthread
  
### Memory:256Mi/1G/268435456/268M
- > 1 G (Gigabyte) = 1000000000 bytes
- > 1 M (Megabyte) = 1000000 bytes
- > 1 K (Kilobyte) = 1000 bytes
- > 1 Gi(Gibibyte) = 1073741824 bytes
- > 1 Mi(Mebibyte) = 1048576 bytes
- > 1 Ki(Kibibyte) = 1024 bytes

### Default memory

```
apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
spec:
  limits:
  - default:
      memory: 512Mi
    defaultRequest:
      memory: 256Mi
    type: Container
  ```
  https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/ 

### Default CPU

```
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-limit-range
spec:
  limits:
  - default:
      cpu: 1
    defaultRequest:
      cpu: 0.5
    type: Container
```    
https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/

### References
https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource

## TAINTS & TOLERATIONS
   * Restrict nodes from accepting certain pods 

1. Nodes = Taints 
2. Pods = Tolerations
3. Master = Do not deploy app
```
kubectl taint nodes node-name key=value:taint-effect
kubectl describe node kubemaster | grep Taint
```
### NoSchedule | PreferNoSchedule | NoExecute
What happens to PODs thar DO NOT TOLERATE this taint?
- NoSchedule: Pods no will be schedule in node
- PreferNoSchedule: System will try to avoid placing the pod on the node, no guarenteed
- No execute: New pods will not be schedule on the node and existing pods on the node if any will be evicted if they do not tolerate the taint. 
  This pods may have been scheduled on the node before the taint was applied to the node
Example
```
kubectl taint nodes node1 app=blue:NoSchedule
```

### Tolerations Pods
```
apiVersion: v1
kind: Pod
metadata:
 name: my-app
spec:
   containers:
   - name: nginx-controller
     image: nginx
   tolerations:
   - key: "app"
     operator: "Equal"
     value: "blue"
     effect: "NoSchedule"
```

## NODE SELECTORS
- Label a node
```
kubectl label nodes <nde_name> <label-key>=<label-value>
kubectl label nodes node-1 size=Large
```
En el yaml file
```
nodeSelector: 
  size: Large
```

## NODE AFFINITY
Ensure that pods are hosted on particular nodes
Large pods inside large nodes
```
affinity:
 nodeAffinity:
   requiredDuringSchedulingIgnoreDuringExecution:
     nodeSelectorTerms:
     - nodeSelectorTerms:
       - matchExpressions:
         - key: size
           operator: Exists / * NotIn
           * values:
           * - Small
```
Types: Available
- requiredDuringSchedulingIgnoreDuringExecution
- preferedDuringSchedulingIgnoreDuringExecution
Types: 
- requiredDuringSchedulingRequiredDuringExecution

